VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "CModel"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Option Explicit

Implements IModel

Dim CellWidth As Integer    'Characters per Cell in output file
Dim convertDollar As Boolean
Dim booktabs As Boolean
Dim tableFloat As Boolean
Dim Indent As Integer
Dim FullText As String
Dim sFileName As String
Dim RangeToUse As Range

Private mpEvents As New IModelEvents

' IModel implementation

Public Property Get IModel_Events() As IModelEvents
    Set IModel_Events = mpEvents
End Property

Public Property Get IModel_Options() As x2lOptions
    If convertDollar Then IModel_Options = IModel_Options Or x2lConvertMathChars
    If booktabs Then IModel_Options = IModel_Options Or x2lBooktabs
    If tableFloat Then IModel_Options = IModel_Options Or x2lCreateTableEnvironment
End Property
Public Property Let IModel_Options(ByVal Options As x2lOptions)
    Dim oldOptions As x2lOptions
    oldOptions = IModel_Options()
    
    convertDollar = (Options And x2lConvertMathChars) <> x2lNone
    booktabs = (Options And x2lBooktabs) <> x2lNone
    tableFloat = (Options And x2lCreateTableEnvironment) <> x2lNone
    
    If oldOptions <> IModel_Options() Then
        mpEvents.RaiseChanged
    End If
End Property

Public Property Get IModel_Indent() As Integer
    IModel_Indent = Indent
End Property
Public Property Let IModel_Indent(ByVal iIndent As Integer)
    If Indent = iIndent Then Exit Property
    Indent = iIndent
    mpEvents.RaiseChanged
End Property

Public Property Get IModel_CellWidth() As Integer
    IModel_CellWidth = CellWidth
End Property
Public Property Let IModel_CellWidth(ByVal iCellWidth As Integer)
    If CellWidth = iCellWidth Then Exit Property
    CellWidth = iCellWidth
    mpEvents.RaiseChanged
End Property

Public Property Get IModel_FileName() As String
    IModel_FileName = sFileName
End Property
Public Property Let IModel_FileName(ByVal iFileName As String)
    Dim sBaseDir As String
    sBaseDir = WorksheetDir
    If UCase(iFileName) Like UCase(sBaseDir) & "\*" Then
        iFileName = Mid$(iFileName, Len(sBaseDir) + 2)
    End If
    sFileName = iFileName
End Property
Public Property Get IModel_AbsoluteFileName() As String
    If sFileName Like "?:\*" Or sFileName Like "\\*\*" Then
        IModel_AbsoluteFileName = sFileName
    Else
        IModel_AbsoluteFileName = Printf("%1\%2", WorksheetDir, sFileName)
    End If
End Property

Public Property Get IModel_RangeAddress() As String
    IModel_RangeAddress = RangeToAddress(RangeToUse)
End Property
Public Property Let IModel_RangeAddress(ByVal iRange As String)
    Set RangeToUse = AddressToRange(iRange)
    mpEvents.RaiseChanged
End Property

Public Function IModel_GetConversionResult() As String
    Dim r As Range
    Dim FileName As String
    Dim i As Integer
    Dim j As Integer
    Dim pos As Integer
    
    FullText = ""
    If RangeToUse Is Nothing Then
        AddText "% Error: No range selected.", True
        GoTo leave
    End If
    AddText Space(Indent) + "% Table generated by Excel2LaTeX from sheet '" + RangeToUse.Worksheet.Name + "'", True
    
    If tableFloat Then
        AddText Space(Indent) + "\begin{table}[htbp]", True
        Indent = Indent + 2
        AddText Space(Indent) + "\centering", True
        AddText Space(Indent) + "\caption{Add caption}", True
        Indent = Indent + 2
    End If
    
    AddText Space(Indent) + "\begin{tabular}{"
    AddText GetColumnsFormat(RangeToUse)
    AddText "}", True
      
    'Start checking top border
    Set r = RangeToUse.Rows(1)
    
    If booktabs Then
        AddText Space(Indent) + "\addlinespace", True
        AddText Space(Indent) + "\toprule", True
    Else
        AddText HorizontalBorder(r, Indent)
    End If
    
    'Table contents:
    For j = 1 To RangeToUse.Rows.Count ' for each row
        Set r = RangeToUse.Rows(j)
        If (j = 2) And booktabs Then
            AddText Space(Indent) + "\midrule", True
        End If
        AddText Space(Indent)
    
        For i = 1 To r.Cells.Count  ' for each cell in row r
            i = i + AddCell(r.Cells(i), i = 1, i >= r.Cells.Count) - 1
            
            If i <> r.Cells.Count Then
              AddText " & "
            End If
        Next i 'cells in row
        
        ' Struts and end of line
        AddText Printf(" %1\\", GetStruts(r)), True
        
        ' Check for Border lines
        If Not booktabs Then
            AddText HorizontalBorder(r.Offset(RowOffset:=1), Indent)
        End If
    Next j 'row
    
theend:      'Tabellenende
    If booktabs Then
        AddText Space(Indent) + "\bottomrule", True
    End If
    AddText Space(Indent) + "\end{tabular}%", True
    
    If tableFloat Then
        Indent = Indent - 2
        AddText Space(Indent) + "\label{tab:addlabel}%", True
        Indent = Indent - 2
        AddText Space(Indent) + "\end{table}%", True
    End If
    
leave:
    IModel_GetConversionResult = FullText
    
    ' Save to registry after successful conversion
    SaveToRegistry
End Function

Public Sub IModel_InitDefault()
    Indent = 0
    CellWidth = 5
    IModel_Options = x2lBooktabs Or x2lConvertMathChars Or x2lCreateTableEnvironment
    
    InitFromRegistry

    Set RangeToUse = GetDefaultRange
    sFileName = GetDefaultFileName
End Sub

Private Property Get IModel_Description() As String
    If RangeToUse Is Nothing Then
        IModel_Description = "(empty range)"
        Exit Property
    End If
    IModel_Description = Me.IModel_RangeAddress
End Property

Private Property Get IModel_Range() As Range
    Set IModel_Range = RangeToUse
End Property
Private Property Set IModel_Range(ByVal pRange As Range)
    Set RangeToUse = pRange.Areas(1)
    mpEvents.RaiseChanged
End Property

' Class implementation

Private Sub InitFromRegistry()
    StringToModel Me, VBA.GetSetting("Excel2LaTeX", "Main", "DefaultSettings")
End Sub

Private Sub SaveToRegistry()
    VBA.SaveSetting "Excel2LaTeX", "Main", "DefaultSettings", ModelToString(Me)
End Sub

Private Function WorksheetDir() As String
    If RangeToUse Is Nothing Then
        WorksheetDir = "."
        Exit Function
    End If
    
    WorksheetDir = RangeToUse.Worksheet.Parent.PATH
End Function

Private Function GetDefaultRange() As Range
    If Selection Is Nothing Then Exit Function
    If TypeName(Selection) <> "Range" Then Exit Function
    
    Set GetDefaultRange = Selection
End Function

Private Function GetDefaultFileName()
    Dim sName As String
    On Error Resume Next
    sName = ActiveSheet.Name
    sName = RangeToUse.Name.Name
    On Error GoTo 0
    GetDefaultFileName = Printf("%1.tex", sName)
End Function

Private Sub AddText(ByVal txt As String, Optional ByVal LineFeed = False)
    If LineFeed Then txt = txt + vbLf
    FullText = FullText + txt
End Sub

Private Function PadSpace(ByVal n As Long)
    PadSpace = Space(Application.WorksheetFunction.Max(0, n))
End Function

Private Function GetStruts(ByVal rRow As Range) As String
    ' No struts in booktabs mode
    If booktabs Then Exit Function
    
    Dim bHasTopBorder As Boolean
    Dim bHasBottomBorder As Boolean
    
    bHasTopBorder = HasHorizontalBorder(rRow)
    bHasBottomBorder = HasHorizontalBorder(rRow.Offset(RowOffset:=1))
    
    If bHasTopBorder Then
        If bHasBottomBorder Then
            GetStruts = "\bigstrut"
        Else
            GetStruts = "\bigstrut[t]"
        End If
    Else
        If bHasBottomBorder Then
            GetStruts = "\bigstrut[b]"
        End If
    End If
End Function

Private Function GetColumnsFormat(ByVal RangeToUse As Range, Optional ByVal bSkipFirst = False, Optional ByVal lStep As Long = 1) As String
    Dim i As Long
    Dim stg As String
    
    If Not bSkipFirst Then
        stg = VerticalBorder(RangeToUse.Columns(1))
    End If
    
    For i = 1 To RangeToUse.Columns.Count Step lStep
        Select Case RangeToUse.Columns(i).HorizontalAlignment
        Case xlLeft
            stg = stg + "l"
        Case xlCenter
            stg = stg + "c"
        Case Else
            stg = stg + "r" 'Default alignment is right
        End Select
        stg = stg + VerticalBorder(RangeToUse.Columns(i + lStep))
    Next i
    GetColumnsFormat = stg
End Function

Private Function VerticalBorder(ByVal pRightRange As Range)
    ' No vertical borders for booktabs style
    If booktabs Then Exit Function
    
    Dim borderStyle As Variant
    borderStyle = pRightRange.Borders(xlLeft).LineStyle
    
    Dim pLeftRange As Range
    If pRightRange.Column > 1 Then
        Set pLeftRange = pRightRange.Offset(ColumnOffset:=-1)
        borderStyle = ResolveLine(borderStyle, pLeftRange.Borders(xlRight).LineStyle)
    End If

    'return nothing, | or ||
    Dim stg As String
    Select Case borderStyle
    Case xlDouble
        stg = "||"
    Case xlContinuous
        stg = "|"
    Case Else
        stg = ""
    End Select
    VerticalBorder = stg
End Function

Private Function HasHorizontalBorder(ByVal rBelowRange As Range) As Boolean
    HasHorizontalBorder = (HorizontalBorder(rBelowRange, 0) <> "")
End Function

Private Function HorizontalBorder(ByVal rBelowRange As Range, ByVal spaces As Integer) As String
    Dim rAboveRange As Range
    If rBelowRange.Row > 1 Then
        Set rAboveRange = rBelowRange.Offset(RowOffset:=-1)
    End If
    
    Dim sRangeDef As String
    Dim lLineOpenFrom As Long
    Dim bOpenLine As Boolean
    Dim borderStyle As Variant
    
    Dim rBelowColumn As Range
    Dim rAboveColumn As Range
    For Each rBelowColumn In rBelowRange.Columns
        If Not rAboveRange Is Nothing Then
            Set rAboveColumn = rAboveRange.Columns(rBelowColumn.Column - rBelowRange.Column + 1)
        End If
        
        If Not IsFirstRowOfMultiRowCell(rBelowColumn) Then
            bOpenLine = False
        Else
            borderStyle = ResolveHorizontalLine(rBelowColumn, rAboveColumn)
            bOpenLine = (borderStyle <> xlNone)
        End If
        
        AppendToRangeSet sRangeDef, lLineOpenFrom, bOpenLine, rBelowColumn.Column - rBelowRange.Column + 1
    Next
    
    AppendToRangeSet sRangeDef, lLineOpenFrom, False, rBelowRange.Columns.Count + 1
    
    ' Straight line? => revert to old behavior
    If sRangeDef = Printf("1-%1", rBelowRange.Columns.Count) Then
        'return nothing, \hline or \hline\hline
        borderStyle = ResolveHorizontalLine(rBelowRange, rAboveRange)
    
        Select Case borderStyle
        Case xlDouble
            HorizontalBorder = Space(spaces) + "\hline" + vbLf + Space(spaces) + "\hline" + vbLf
        Case xlContinuous
            HorizontalBorder = Space(spaces) + "\hline" + vbLf
        Case Else
            HorizontalBorder = ""
        End Select
    ElseIf sRangeDef = "" Then
        HorizontalBorder = ""
    Else
        HorizontalBorder = Printf("\cline{%1}", Replace(sRangeDef, ";", "}\cline{"))
    End If
End Function

Public Sub AppendToRangeSet(ByRef sRangeDef As String, ByRef lLineOpenFrom As Long, ByVal bOpenLine As Boolean, ByVal lCurrentPos As Long)
    If bOpenLine Then
        If lLineOpenFrom <= 0 Then
            lLineOpenFrom = lCurrentPos
            sRangeDef = Printf("%1%3%2", sRangeDef, lCurrentPos, IIf(sRangeDef = "", "", ";"))
        End If
    Else
        If lLineOpenFrom > 0 Then
            sRangeDef = Printf("%1-%2", sRangeDef, lCurrentPos - 1)
            lLineOpenFrom = 0
        End If
    End If
End Sub

Private Function ResolveHorizontalLine(ByVal rBelowRange As Range, ByVal rAboveRange As Range)
    ResolveHorizontalLine = rBelowRange.Borders(xlTop).LineStyle
    If rAboveRange Is Nothing Then Exit Function
    ResolveHorizontalLine = ResolveLine(ResolveHorizontalLine, rAboveRange.Borders(xlBottom).LineStyle)
End Function

Private Function ResolveLine(ByVal line1, ByVal line2)
    ResolveLine = xlNone
    If line1 = xlContinuous Or line2 = xlContinuous Then ResolveLine = xlContinuous
    If line1 = xlDouble Or line2 = xlDouble Then ResolveLine = xlDouble
End Function

Private Function AddCell(ByVal rCell As Range, ByVal bFirstCell As Boolean, ByVal bLastCell As Boolean) As Long
    Dim txt As String
    Dim nColumns As Long
    Dim nRows As Long
    
    txt = rCell.Text
    
    'Check for special characters % and $
    If convertDollar Then
        txt = Replace(txt, "\", "\textbackslash ")
        txt = Replace(txt, "$", "\$")
        txt = Replace(txt, "_", "\_")
        txt = Replace(txt, "^", "\^")
    End If
    txt = Replace(txt, "%", "\%")
    txt = Replace(txt, "&", "\&")
    txt = Replace(txt, "#", "\#")
                
    'Check for Font Styles
    If rCell.Font.Bold Then txt = Printf("\textbf{%1}", txt)
    If rCell.Font.Italic Then txt = Printf("\textit{%1}", txt)
    
    'Check for multicolumns
    If rCell.MergeCells Then   'multicolumn cell
        With rCell.MergeArea
            nColumns = .Columns.Count
            nRows = .Rows.Count
        End With
        
        If nRows > 1 Then
            ' Add contents only for first row of a multi-row cell
            If IsFirstRowOfMultiRowCell(rCell) Then
                txt = Printf("\multirow{%1}{*}{%2}", nRows, txt)
            Else
                txt = ""
            End If
        End If
        If nColumns > 1 Then
            txt = Printf("\multicolumn{%1}{%2}{%3}", _
                nColumns, _
                GetColumnsFormat(rCell.MergeArea, Not bFirstCell, rCell.MergeArea.Columns.Count), _
                txt)
        End If
    Else 'single cell
        nColumns = 1
        nRows = 1
    End If
    
    AddText txt
    If Not bLastCell Then
        AddText PadSpace(nColumns * (3 + CellWidth) - 3 - Len(txt))
    End If
    
    AddCell = nColumns
End Function

Function IsFirstRowOfMultiRowCell(ByVal rCell As Range) As Boolean
    IsFirstRowOfMultiRowCell = (rCell.Row = rCell.MergeArea.Row)
End Function
