VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "CModel"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Option Explicit

Implements IModel

Dim CellWidth As Integer    'Characters per Cell in output file
Dim convertDollar As Boolean
Dim booktabs As Boolean
Dim tableFloat As Boolean
Dim Indent As Integer
Dim FullText As String
Dim sFileName As String

' IModel implementation

Public Property Get IModel_Options() As x2lOptions
    If convertDollar Then IModel_Options = IModel_Options Or x2lConvertMathChars
    If booktabs Then IModel_Options = IModel_Options Or x2lBooktabs
    If tableFloat Then IModel_Options = IModel_Options Or x2lCreateTableEnvironment
End Property
Public Property Let IModel_Options(ByVal Options As x2lOptions)
    convertDollar = (Options And x2lConvertMathChars) <> x2lNone
    booktabs = (Options And x2lBooktabs) <> x2lNone
    tableFloat = (Options And x2lCreateTableEnvironment) <> x2lNone
End Property

Public Property Get IModel_Indent() As Integer
    IModel_Indent = Indent
End Property
Public Property Let IModel_Indent(ByVal iIndent As Integer)
    iIndent = Indent
End Property

Public Property Get IModel_CellWidth() As Integer
    IModel_CellWidth = CellWidth
End Property
Public Property Let IModel_CellWidth(ByVal iCellWidth As Integer)
    iCellWidth = CellWidth
End Property

Public Property Get IModel_FileName() As String
    IModel_FileName = sFileName
End Property
Public Property Let IModel_FileName(ByVal iFileName As String)
    iFileName = sFileName
End Property

Public Function IModel_GetConversionResult() As String
    Dim txt As String
    Dim txt2 As String
    Dim multicells As Integer
    Dim RangeToUse As Range
    Dim r As Range
    Dim FileName As String
    Dim i As Integer
    Dim j As Integer
    Dim pos As Integer
    
    multicells = 0
    Set RangeToUse = Selection
    
    FullText = Space(Indent) + "% Table generated by Excel2LaTeX from sheet '" + ActiveSheet.Name + "'" + vbLf
    
    If tableFloat Then
        AddText Space(Indent) + "\begin{table}[htbp]", True
        Indent = Indent + 2
        AddText Space(Indent) + "\centering", True
        AddText Space(Indent) + "\caption{Add caption}", True
        Indent = Indent + 2
    End If
    
    AddText Space(Indent) + "\begin{tabular}{"
    AddText GetColumnsFormat(RangeToUse)
    AddText "}", True
      
    'Start checking top border
    Set r = RangeToUse.Rows(1)
    
    If booktabs Then
        AddText Space(Indent) + "\addlinespace", True
        AddText Space(Indent) + "\toprule", True
    Else
        AddText HorizontalBorder(r, Indent)
    End If
    
    'Table contents:
    For j = 1 To RangeToUse.Rows.Count ' for each row
        Set r = RangeToUse.Rows(j)
        If (j = 2) And booktabs Then
            AddText Space(Indent) + "\midrule", True
        End If
        AddText Space(Indent)
    
        For i = 1 To r.Cells.Count  ' for each cell in row r
            txt = r.Cells(i).Text
            
            'Check for special characters % and $
            If convertDollar Then
                txt = Replace(txt, "\", "\textbackslash ")
                txt = Replace(txt, "$", "\$")
                txt = Replace(txt, "_", "\_")
                txt = Replace(txt, "^", "\^")
            End If
            txt = Replace(txt, "%", "\%")
            txt = Replace(txt, "&", "\&")
            txt = Replace(txt, "#", "\#")
                        
            'Check for Font Styles
            If r.Cells(i).Font.Bold Then txt = "{\bf " + txt + "}"
            If r.Cells(i).Font.Italic Then txt = "{\it " + txt + "}"
            
            'Check for multicolumns
            If r.Cells(i).MergeCells Then   'multicolumn cell
                multicells = r.Cells(i).MergeArea.Columns.Count
                txt2 = "\multicolumn{" + Str(multicells) + _
                        "}{" + GetColumnsFormat(r.Cells(i))
                txt2 = txt2 + "}{" + txt + "}"
                AddText txt2
                If i < r.Cells.Count Then
                    AddText PadSpace(multicells * (3 + CellWidth) - 3 - Len(txt2))
                End If
                i = i + multicells - 1
            Else 'single cell
                AddText txt
                If i < r.Cells.Count Then
                    AddText PadSpace(CellWidth - Len(txt))
                End If
            End If
            If i <> r.Cells.Count Then
              AddText " & "
            End If
        Next i 'cells in row
        
        AddText " \\", True
          ' Check for Border lines
        If Not booktabs Then
            AddText HorizontalBorder(r.Offset(RowOffset:=1), Indent)
        End If
    Next j 'row
    
theend:      'Tabellenende
    If booktabs Then
        AddText Space(Indent) + "\bottomrule", True
    End If
    AddText Space(Indent) + "\end{tabular}"
    
    If tableFloat Then
        Indent = Indent - 2
        AddText "", True
        AddText Space(Indent) + "\label{tab:addlabel}", True
        Indent = Indent - 2
        AddText Space(Indent) + "\end{table}"
    End If
    
    IModel_GetConversionResult = FullText
End Function

Private Sub AddText(ByVal txt As String, Optional ByVal LineFeed = False)
    If LineFeed Then txt = txt + vbLf
    FullText = FullText + txt
End Sub

Private Function PadSpace(ByVal n As Long)
    PadSpace = Space(Application.WorksheetFunction.Max(0, n))
End Function

Private Function GetColumnsFormat(ByVal RangeToUse As Range) As String
    Dim i As Long
    Dim stg As String
    stg = VerticalBorder(RangeToUse.Columns(1))
    For i = 1 To RangeToUse.Columns.Count
        Select Case RangeToUse.Columns(i).HorizontalAlignment
        Case xlLeft
            stg = stg + "l"
        Case xlCenter
            stg = stg + "c"
        Case Else
            stg = stg + "r" 'Default alignment is right
        End Select
        stg = stg + VerticalBorder(RangeToUse.Columns(i + 1))
    Next i
    GetColumnsFormat = stg
End Function

Private Function VerticalBorder(ByVal pRightRange As Range)
    ' No vertical borders for booktabs style
    If booktabs Then Exit Function
    
    Dim borderStyle As Variant
    borderStyle = pRightRange.Borders(xlLeft).LineStyle
    
    Dim pLeftRange As Range
    If pRightRange.Column > 1 Then
        Set pLeftRange = pRightRange.Offset(ColumnOffset:=-1)
        borderStyle = ResolveLine(borderStyle, pLeftRange.Borders(xlRight).LineStyle)
    End If

    'return nothing, | or ||
    Dim stg As String
    Select Case borderStyle
    Case xlDouble
        stg = "||"
    Case xlContinuous
        stg = "|"
    Case Else
        stg = ""
    End Select
    VerticalBorder = stg
End Function

Private Function HorizontalBorder(ByVal pBelowRange As Range, ByVal spaces As Integer)
    Dim borderStyle As Variant
    borderStyle = pBelowRange.Borders(xlTop).LineStyle
    
    Dim pAboveRange As Range
    If pBelowRange.Row > 1 Then
        Set pAboveRange = pBelowRange.Offset(RowOffset:=-1)
        borderStyle = ResolveLine(borderStyle, pAboveRange.Borders(xlBottom).LineStyle)
    End If
    
    'return nothing, \hline or \hline\hline
    Dim stg As String
    Select Case borderStyle
    Case xlDouble
        stg = Space(spaces) + "\hline" + vbLf + Space(spaces) + "\hline" + vbLf
    Case xlContinuous
        stg = Space(spaces) + "\hline" + vbLf
    Case Else
        stg = ""
    End Select
    HorizontalBorder = stg
End Function

Private Function ResolveLine(ByVal line1, ByVal line2)
    ResolveLine = xlNone
    If line1 = xlContinuous Or line2 = xlContinuous Then ResolveLine = xlContinuous
    If line1 = xlDouble Or line2 = xlDouble Then ResolveLine = xlDouble
End Function


